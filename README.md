Last Updated on 2018-06-20
Copyright (C) 2018  Pintaudi Giorgio

# NU-VS-ANTINU

## Introduction

nu-vs-antinu is a simple program whose only purpose is to generate a certain 
graph useful in the analysis of data from long-baseline neutrino experiments.
In this context by graph we merely mean a simple 2D figure. On the horizontal
axis the oscillation probability of muon neutrinos to electron neutrinos after 
they traveled for a certain distance, while on the vertical axis the
oscillation probability of muon anti-neutrinos to electron anti-neutrinos.

The oscillation probabilities for neutrinos and anti-neutrinos are calculated
after fixing all the mixing angles and squared mass parameters in the PMNS
matrix. Only the CP violation phase delta is varied from 0 to 2pi, i.e. the 
whole dominion of definition. The ellipses that can be seen in the example figure
NOvA.png express just the dependence of the P(anti-mu->anti-e) and P(mu->e) on
the delta phase, where P(x->y) is the probability that the neutrino or 
anti-neutrino of flavor x oscillates into the neutrino or anti-neutrino of 
flavor y.

## NOvA experiment latest results (as of May 2018)

The figure NOvA.png was not generated by this program but it is taken from
the slides of Mayly Sanchez's presentation at Neutrino 2018, whose title was
"NOvA Results and Prospects (Neutrino 2018)". These slides are publicly 
available at 
[this adress](http://nova-docdb.fnal.gov/cgi-bin/ShowDocument?docid=30249)

Anyway, this program is able to accurately reproduce the said figure if the 
detector sensibility is ignored, i.e. to faithfully reproduce the NOvA.png 
picture we would need to know the detector sensitivity and the precise flux 
of neutrinos at the far detector. 

By changing the input parameters to the program at runtime, the same picture 
can be drawn for other long-baseline neutrino experiments such as T2K. This
enables us to directly and quickly compare the two experiments as far as the 
sensitivity to the mass hierarchy order is concerned (more details on this in 
the following).

## Output graphs and resolution against the hierarchy problem

Each picture produced by this program, like the example picture NOvA.png, 
displays four ellipses. These ellipses correspond to the four cases:
 -    Normal Hierarchy - Upper Octant (for the theta23 mixing angle)
 -    Normal Hierarchy - Lower Octant
 -    Inverted Hierarchy - Upper Octant
 -    Inverted Hierarchy - Lower Octant
These graphs provide a quick way to assess if and how much an experiment is 
sensible to the neutrino mass ordering and to a lesser extent to the CP
violation phase value, i.e. how well an experiment is able to distinguish the
neutrino mass ordering or the value of delta. In other words, the more the 
ellipses corresponding to normal or inverted hierarchy are far apart and well
separated, the more the experiment is sensitive to the neutrino mass order.

The picture NOvA.png contains also the point with error bars corresponding to 
the measured electronic neutrino vs anti-neutrino events at the NOvA far 
detector. The data gathered by the NOvA experiment show a weak preference for 
the Normal Hierarchy - Upper Octant. Anyway, the statistical errors are still
quite large and prevent from a definitive answer in that regard.

An important point that we want the reader to understand before discussing
further details is that the ellipses drawn by this program are the result
of a simulation and therefore don't carry any information about the data
effectively gathered by the experiment which one is trying to simulate. The only 
experimental data entering the simulation is contained in the value of the
input oscillation parameters. The target experiment geometry and properties
are condensed in only two variables, the baseline distance and the neutrino
flux mean energy.

## Prob3++ (version 2.10)

To determine the oscillation probabilities the library called Prob3++, written
by some members of the HyperKamiokande collaboration and publicly available 
[here on GitHub](https://github.com/hyperk/Prob3), is used. 
The Prob3++ source code is released without specifying the license. Though not 
the sole author, Roger Wendell (-rvw) is presently maintaining the software so
we acknowledge him as the main author of the Prob3++ library.

Before compiling our program, the reader is assumed to have already downloaded
and compiled the Prob3++ library as explained 
[here](https://github.com/hyperk/Prob3). The compilation output of Prob3++ is
the static library file "libThreeProb_2.10.a". This must be fed to the linker
at compiling time. Our code also assumes that the file "BargerPropagator.h" has
been copied in the same folder as the source code. We already bundle it so the
user is not required to do anything. Optionally, the path to this header file
can be changed at the beginning of the "nu_vs_antinu.cc" source code file.

## Boost libraries (Version 1.63.0)

From the [boost.org](https://www.boost.org/) homepage:
> Boost provides free peer-reviewed portable C++ source libraries.
> 
> We emphasize libraries that work well with the C++ Standard Library. Boost 
> libraries are intended to be widely useful, and usable across a broad spectrum 
> of applications. The Boost license encourages both commercial and 
> non-commercial use.
> 
> We aim to establish "existing practice" and provide reference implementations 
> so Boost libraries are suitable for eventual standardization. Ten Boost 
> libraries are included in the C++ Standards Committee's Library Technical 
> Report (TR1) and in the new C++11 Standard. C++11 also includes several more 
> Boost libraries in addition to those from TR1. More Boost libraries are 
> proposed for standardization in C++17.

Before compiling our code the user needs first install the program-options
boost library. From the program-options 
[webpage](https://www.boost.org/users/history/version_1_63_0.html):
> The program_options library allows program developers to obtain program 
> options, that is (name, value) pairs from the user, via conventional methods 
> such as command line and config file.
> 
> Why would you use such a library, and why is it better than parsing your 
> command line by straightforward hand-written code?
> - It's easier. The syntax for declaring options is simple, and the library 
> itself is small. Things like conversion of option values to desired type and 
> storing into program variables are handled automatically.
> - Error reporting is better. All the problems with the command line are 
> reported, while hand-written code can just misparse the input. In addition, 
> the usage message can be automatically generated, to avoid falling out of 
> sync with the real list of options.
> 
> Options can be read from anywhere. Sooner or later the command line will be 
> not enough for your users, and you'll want config files or maybe even 
> environment variables. These can be added without significant effort on your 
> part.
### Installation
- Linux
Usually boost is already present in the default repositories of most Linux
distributions. For instance, Ubuntu 17.10 users can install boost program option 
library with the following command
```
sudo apt-get install libboost-program-options1.63*
```
If your Linux distribution doesn't bundle boost you can download it and compile
it following the instructions 
[here](https://www.boost.org/users/history/version_1_63_0.html). It highly 
probable that even newer and future versions of boost will be compatible with
our code.
- OSX
Download and install [MacPorts](https://www.macports.org/install.php), and run 
the following command:
```
sudo port install boost
```

## ROOT 6.12/06

The graphs are plotted using ROOT primitives, so, a valid root installation is
required both at compilation time and at runtime. You can get ROOT 6.12 at this
[link](https://root.cern.ch/content/release-61206). Again newer and future 
versions of ROOT are very likely to work well with our code since no advanced
feature is used. Before compilation make sure that the right environment for
ROOT is set up by issuing:
```
source YOUR_ROOT_PATH/bin/thisroot.sh
```
for bash-like shells or
```
source YOUR_ROOT_PATH/bin/thisroot.csh
```
csh-like shells.

## Compilation

Our simple code can be compiled with a single line expression. We just need
to link all the needed libraries
```
g++ -o nu_vs_antinu nu_vs_antinu.cc libThreeProb_2.10.a \
-lm -lboost_program_options `root-config --cflags --ldflags --glibs`
```
We tested the code only in a Linux environment. OSX and Windows-Cygwin are
not tested so modification to the compile command may be due. In the command
above the "libThreeProb_2.10.a" file is assumed to be in the same folder
as the source code. If the relative path to that file is different, be sure to
input it correctly.

Moreover be sure to have sourced ROOT environment setup file "thisroot.(c)sh" as
explained in the previous section.

## Usage

Like already pointed out above, the only output of this program is a root file
whose name can be specified as a run-time option. This file contains a graph
that needs ROOT to be displayed. Since the produced graph can be different
for different experimental configurations, the instructions to be passed to
ROOT to render the graph slightly differ. Two example files named "plotNOvA.C"
and "plotT2K.C" are provided as a reference for the NOvA and T2K experiment
respectively.

The program "nu_vs_antinu" allowed options are
```
  --help                             produce help message
  --DM21 arg                         DeltaM^2_21 in 10^-5 eV^2
  --DM32NH arg                       DeltaM^2_32 in 10^-3 eV^2 - Normal 
                                     Hierarchy (positive sign)
  --DM32IH arg                       DeltaM^2_32 in 10^-3 eV^2 - Inverted 
                                     Hierarchy (negative sign)
  --theta12 arg                      Sin^2(theta12)
  --theta13 arg                      Sin^2(theta13)
  --theta23LO arg                    Sin^2(theta23) - Lower Octant
  --theta23UO arg                    Sin^2(theta23) - Upper Octant
  --density arg                      Continental Crust Density in g/cm^3
  --energy arg                       Mean Beam Energy in GeV
  --distance arg                     Distance to Far Detector in Km
  -o [ --output ] arg (=output.root) Output ROOT file name
```

The "output.root" file is a binary file which needs ROOT to be read.
For example:
```
root -l output.root plotNOvA.C
```
for the case of the NOvA experiment and
```
root -l output.root plotT2K.C
```
for the case of the T2K experiment.

## Approximations and assumptions

If the user doesn't specify any parameter at run-time the following values are
assumed:
 - The mass splitting M^2_2 - M^2_1 (DeltaM^2_21) is assumed to be 7.55e-05 eV^2
 - The mass splitting DM32 for the normal hierarchy is assumed to be 0.0025 eV^2
 - The mass splitting DM32 for the inverted hierarchy is assumed to be -0.00255 eV^2
 - The Sin^2(theta12) oscillation angle is assumed to be 0.32
 - The Sin^2(theta13) oscillation angle is assumed to be 0.021
 - The Sin^2(theta23) oscillation angle for the lower octant is assumed to be 0.46
 - The Sin^2(theta23) oscillation angle for the upper octant is assumed to be 0.59
 - The average density of continental crust is assumed to be 2.7 g/cm^3
 - The mean energy of the neutrino beam was set to 0.6 GeV
 - The distance to the far detector was set to 295 Km
The user can change and specify all the above parameters by the relative 
program arguments.

The following assumptions were also taken:
 - The material through which the neutrinos travel is the earth crust whose
density is assumed uniform.
 - There are only three generations of neutrinos and no sterile neutrino 
component is considered
 - Only the oscillation probability is given and no sensibility nor precision
of the far detector is taken into account. 
 - The neutrinos flux is assumed monochromatic
 - Error bars are not calculated so the input values are assumed perfectly known. 

## License

Copyright (C) 2018  Pintaudi Giorgio <giorgio-pintaudi-kx_AT_ynu_DOT_jp>

This file is part of nu-vs-antinu.
nu-vs-antinu is a simple program that produces a graph to quickly estimate 
the sensibility of a given experiment to the neutrino mass hierarchy.

nu-vs-antinu is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

nu-vs-antinu is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with nu-vs-antinu.  If not, see <https://www.gnu.org/licenses/>.

















